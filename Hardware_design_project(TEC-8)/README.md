------------------
# &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;计算机CPU设计项目报告
------------------

### 实验前导

>&#160; &#160; &#160; &#160;计算机组成原理是计算机应用和计算机软件以及其他相关专业必修的专业基础课程，它主要讨论计算机各组成部件的基本概念、基本结构、工作原理及设计方法。对该课程的学习，能够帮助我们建立整机的概念，研究各部件的在实际工作中的原理、以及相互连接与相互作用，并为各功能部件的逻辑设计打下良好的理论基础，提高我们计算机课程学习的系统性。

>&#160; &#160; &#160; &#160;在大二春季学期，我们系统地学习了计算机组成原理理论课学习，完成了计算机组成原理TEC-8实验平台的相关实验，对于TEC-8实验平台的组成模块、工作机制、参数配置都有了初步的了解，为本次计算机组成原理课程设计打下了良好的基础。本次计算机组成原理就是基于TEC-8实验平台进行设计。

## 一.实验目的

### 1.融会贯通计算机组成原理各章节的内容

- 通过知识的综合运用加深对计算机各模块的工作原理及相互联系的认识，特别是对硬布线控制器的认识；
- 建立清晰的整机概念，对计算机工作原理建立整体性的认识，可以完整地构建计算机指令存储、执行、反馈的全过程；

### 2.掌握硬布线控制器的设计方法

- 能够深入理解硬布线控制器和微程序
- 控制器各自的工作原理、工作流程、以及相互之的区别；
- 掌握TEC-8实验平台上硬布线控制器的工作原理、操作方法、以及进行硬布线控制器操作时可采用的调试方法；

### 3.掌握运用可编程技术进行逻辑设计和调试的基本步骤和方法

- 熟悉集成开发软件中设计、模拟调试工具的使用；
- 体会可编程逻辑技术相对于传统开发技术的优点；
- 
### 4.培养科学研究的独立工作能力，取得工程设计与组装调试的实践经验

- 本次实验为硬件与软件相结合的实验，对实验人员的动手能力、基本理论掌握程度、程序设计能力提出较高的要求，通过与实际实验相结合的方式可以促进实验团队对计算机组成原理理论知识进行进一步的理解、巩固；
- 本次实验为团队合作实验，意在提高小组成员之间的相互协作能力，强化小组内分模块设计、整体性组装调试的能力，提高实验人员的计算机软件协作开发能力；

## 二.实验要求

### 1.设计

&#160; &#160; &#160; &#160;根据给定的数据格式、指令系统和数据通路，在所提供的器件范围内，设计一个基于硬布线控制器的顺序模型处理器；

### 2.实现

&#160; &#160; &#160; &#160;根据设计方案，在通用台TEC-8上进行组装并调试成功；

### 3.文档

&#160; &#160; &#160; &#160;在组装调试成功的基础上完成课程设计报告。至少包括：

- 数据通路图

- 硬布线控制器逻辑模块图

- 硬布线控制器指令周期流程图

- 控制模块VHDL语言源程序/原理图（需包含说明和注释）

- 模拟向量测试方程/测试波形图/testbench

- 设计说明书--说明设计步骤、实验过程、结论等

- 设计与调试总结--设计与调试过程中遇到的各种问题及解决方法

### 4.实验开发环境

## 三.设计思路

### 1.参数说明

### 2.硬布线控制器的设计思路

&#160; &#160; &#160; &#160;硬连线控制器的常规CPU主要实现写寄存器、读寄存器、写存储器、读存储器、执行指令五项大功能，我小组采用分模块设计的思想来设计VHDL可执行程序，具体步骤如下：

#### 2.1 初始化

- 当执行CLR时：

&#160; &#160; &#160; &#160;当执行CLR时，说明所有的输出参数需要全部置为'0'，表明输出参数全部被初始化，程序执行进入CLR步。伪代码如下：
	
	Set:all element = '0'

- 不执CLR时：

&#160; &#160; &#160; &#160;由于在读存储器、写寄存器操作和写存储器操作中会出现循环的情况，因此，在不执行CLR的情况下，初始化的情况将有所不同。我们在VHDL可执行程序中设置有名为STTO和STO的FLAG标志，分别标志是否进入循环，以及进入循环的标志。我们根据硬连线控制器周期流程图中STTO有效的情况，写出其对应的逻辑表达式，当逻辑表达式有效，即STTO为有效'1'时，置STO为有效位'1'，标志可以进入到循环中。**（注意：当‘STTO=1’时，由于只有在执行完所有'STO=0'下的操作后，我们才能够转入对应的'STO=1'的情况，这就要求我们把握置STO为有效位‘1’的时机，我小组采用T3时刻下降沿置数的方式，能够保证程序按照正常的逻辑进行执行，不会出现抢先执行的情况，保证了程序能够有序地执行。）**为保证执行过程中出现意外情况，我们同时将其他参数置为无效位'0'。设计伪代码如下：

	Set:all elements is '0' (except STTO and STO)
	if STTO ='1':
		if T3'event and T3='0':
			Set STO is '1'		

### 2.2写寄存器

&#160; &#160; &#160; &#160;当`SW='100'`时，系统进入写寄存器操作。在写寄存器操作中，由于写操作分为两个部分，即初始进入初始写操作部分和循环写操作部分，这种情况下，FLAG标志STTO和STO发挥了它们真正的作用，当SSTO为'1'时，表明可进入循环写操作模式，赋值STO为有效位为'1'。我们可以根据周期流程图中的状态，我们可以整理出其对应的逻辑表达式。设计伪代码如下：
	
	if sw='100':
		set:SBUS is W(1) OR W(2)
			SELCTL is W(1) OR W(2)
			DRW is W(1) OR W(2)
			STOP is W(1) OR W(2)
			SST0 is NOT ST0 AND W(2)
			SEL(3) is ST0
			SEL(2) is W(2)
			SEL(1) is (NOT ST0 AND W(1)) OR (ST0 AND W(2))
			SEL(0) is W(1)

### 2.3读寄存器

&#160; &#160; &#160; &#160;当`SW='011'`时，系统进入读寄存器操作，在之前的计算机组成原理实验中我们知道，由于TEC-8上一共4个寄存器，所以通过`A7~A0`和`B7~B0`一次读两个的方式读出寄存器中的内容，所以在实际操中按两次QD即可。操作执行需要两个节拍脉冲，即W1和W2。设计伪代码如下：

	if SW='011':
		Set:
			SEL(3) is W(2)
			SEL(2) is '0'
			SEL(1) is W(2)
			SEL(0) is W(1) OR W(2)
			SELCTL is W(1) OR W(2)
			STOP is W(1) OR W(2)

### 2.4读存储器

&#160; &#160; &#160; &#160;当`SW='010'`时，系统进入读存储器操作，由于在读存储器操作中存在初始读操作模式和循环读操作模式，因此在此处STTO和STO派上了用场。此外，由于读操作为短操作，正常情况下控制台产生W1和W2两个节拍脉冲，为了终止W2节拍脉冲的产生，所以在W1节拍结束之后需要置SHORT为有效位‘1’,TEC-8控制台在接到SHORT有效的信号时，将会终止产生W2脉冲信号，从而进入循环写操作模式中来。设计伪代码如下：

	if SW='010':
		Set:	
			SBUS is W(1) AND NOT ST0
			LAR is W(1) AND NOT ST0
			SST0 is W(1) AND NOT ST0
			MBUS is W(1) AND ST0
			ARINC is W(1) AND ST0
			STOP is W(1)
			SHORT is W(1)
			SELCTL is W(1)

### 2.5写存储器

&#160; &#160; &#160; &#160;当`SW='001'`时，系统进入写存储器操作。在该操作下存在初始写操作模式和循环写操作模式，由于在读存储器操作中，我们首先在SD7~SD0上设置存储器地址，按QD打入到地址寄存器AR。之后不断在数据开关上设置数据，打入即可。因此在写存储器操作中，将进入循环的状态，知道按CLR结束或者写到地址位`'11111111'`。`SSTO`的引入保证了在正确的节拍脉冲中开启，外部的`T3`下降沿又保证了`STO`只有在`T3`下降沿才会改变。这样才能保证写存储器操作能够去按照正确的顺序进行执行。设计的伪代码如下：
	
	if sw='001':
		Set:
			LAR is W(1) AND NOT ST0
			MEMW is W(1) AND ST0
			ARINC is W(1) AND ST0
			SBUS is W(1)
			STOP is W(1)
			SHORT is W(1)
			SELCTL is W(1)
			SST0 is W(1)	

### 2.6取指操作

&#160; &#160; &#160; &#160;重头戏来了！

&#160; &#160; &#160; &#160;当`SW='000'`时，系统进入取指操作中。系统中的取指操作是整个系统中的重点部分，本次实验所接触到的指令的执行方法，在实际的计算机指令执行过程依然使用这种方法。在此操作中系统可选择执行十项计算机指令操作，分别为ADD（加法）、SUB（减法）、AND（逻辑与）、INC（加1）、LD（取数）、ST（存数）、JC（C条件转移）、JZ（Z条件转移）、JMP（无条件转移）、STP（停机）。`IR7~IR4`信号唯一标志了采用什么样的操作，在进入取指操作后，会根据`IR`的具体数值来进行那种动作。其中，LD（取数）、ST（存数）需要在三个节拍电位中执行，而其余的操作须在两个节拍电位中执行完毕。因此，在LD、ST指令执行到W2节拍电位时，须将LONG输出信号置为有效位'1'，表示在产生完W2节拍信号后，TEC-8实验平台还需要继续产生W3节拍电位，保证LD、ST操作能够完整地执行，其处理方法与标志SHORT信号有效，终止产生W2信号的方式相似。值得提及的是，在实际设计的系统中，我们采用SHORT和LONG信号，保证了根据指令执行的需要系统产生正确的节拍电位信号，本功能设计的伪代码如下：

	if SW="000"：
		Toward IR7~IR4:
			if "0001":
				ADD（加法）;
			else if "0010":
				SUB（减法）;
			else if "0011":
				AND（逻辑与）;
			else if "0100":
				INC（加1）;
			else if "0101":
				LD（取数）;
			else if "0110":
				ST（存数）;
			else if "0111":
				JC（C条件转移）;
			else if "1000":
				JZ（Z条件转移）;
			else if	"1001":
				JMP（无条件转移）;
			else if "1110":
				STP（停机）；
			else:	
				NULL;	 

##### 具体操作的细化：

###### ADD（加法）
	
	if IR="0001":
		Set:
			S is W(2) & '0' & '0' & W(2);
			CIN is W(2);
			ABUS is W(2);
			DRW is W(2);
			LDZ is W(2);
			LDC is W(2);

###### SUB（减法）

	if IR="0010":
		Set:
			S is '0' & W(2) & W(2) & '0';
			ABUS is W(2);
			DRW is W(2);
			LDZ is W(2);
			LDC is W(2);

###### AND（逻辑与）

	if IR="0011":
		Set:
			M is W(2);
			S is W(2) & '0' & W(2) & W(2);
			ABUS is W(2);
			DRW is W(2);
			LDZ is W(2);

###### INC（加1）

	if IR="0100":
		Set:
			S is "0000";
			ABUS is W(2); 
			DRW is W(2);
			LDZ is W(2);
			LDC is W(2);

###### LD（取数）

	if IR="0101":
		Set:
			M is W(2);
			S is W(2) & '0' & W(2) & '0';
			ABUS is W(2);
			LAR is W(2);
			LONG is W(2);
			DRW is W(3);
			MBUS is W(3);

###### ST（存数）

	if IR="0110":
		Set:
			M is W(2) OR W(3);
			S is  (W(2) OR W(3)) & W(2) & ( W(2) OR W(3) ) & W(2);
			ABUS is W(2) OR W(3);
			LAR is W(2);
			LONG is W(2);
			MEMW is W(3);		

###### JC（C条件转移）

	if IR="0111":
		Set:
			PCADD is W(2) AND C;

###### JZ(Z条件转移)

	if IR="1000":
		Set:
			PCADD is W(2) AND Z;
 
###### JMP（无条件转移）

	if IR="1001":
		Set:
			M is W(2);
			S is W(2) & W(2) & W(2) & W(2);
			ABUS is W(2);
			LPC is W(2);	

###### STP（停机）

	if IR="1110":
		Set:
			STOP is w(2);

### 2.7 理论上实现中断系统

&#160; &#160; &#160; &#160;假设芯片有引脚能够接收到时序产生器发出的的PULSE信号，并能向时序产生器发出LIAR，INTEN, INTDI信号。首先需添加以下指令：

- 1.EI：指令EI用于允许中断， 执行EI后， CPU向时序产生器发送INTEN信号， 当时序产生器收到该信号时， 将中断允许触发器EN_INT置为1， 允许中断；

- 2.DI：指令DI用于屏蔽中断，执行DI后，CPU向时序产生器发送INTDI信号，当时序产生器收到该信号时， 将中断允许触发器EN_INT置为0， 屏蔽中断；

- 3.IRET：指令IRET用于从中断地址返回。 该指令产生IABUS信号， 将断点地址送数据总线DBUS， 产生信号LPC， 将断点地址从数据总线送入PC， 恢复中断的程序。

&#160; &#160; &#160; &#160;为响应中断，在CPU中设置一个寄存器 ISINT， 为1标志正在进行中断跳转处理， 为0则标志程序正在执行。并添加如下信号：

- 1.SISINT， SISINT用于将ISINT置为1，使CPU在执行完当前指令后，能够进入设置中断向量的状态；

- 2.CISINT用于将和SISINT 和ISINT置为0， 使CPU回到程序执行状态；

- 3.WILLPULSE 信号表示接收到中断请求信号。

&#160; &#160; &#160; &#160;在CPU接收到中断请求信号PULSE时，将WILLPULSE置为1。 在当前指令的最后一拍（根据IR7-4决定最后一拍是W2 还是 W3）的T3时刻使SSINT有效，并在SSINT 下降沿将 ISINT 置为1， CPU进入设置中断向量状态。 在设置中断向量状态的 W1 拍， CPU发出LIAR信号将PC当前指存入中断地址寄存器IAR， 发出信号STOP等待输入中断向量， 并发出INTDI信号屏蔽中断， 以避免二级中断发生。 在W2拍， 将中断向量存入PC， 并在T3下降沿将SISINT和ISINT置为0， 使CPU恢复到程序执行状态， 开始执行中断程序。

&#160; &#160; &#160; &#160;中断程序的倒数第二条指令是EI， 重新允许中断。

&#160; &#160; &#160; &#160;中断程序最后一条指令是IRET， 从中断地址返回， 该指令产生IABUS信号，将保存的断点地址送往DBUS， 在产生LPC， 将断点从数据总线装入PC，  恢复被中断的程序。


&#160; &#160; &#160; &#160;各个新增信号的逻辑表达式：


&#160; &#160; &#160; &#160;LIAR <= ((not SWC) and (not SWB) and (not SWA)) and W1 and STO and ISINT;

&#160; &#160; &#160; &#160;INTEN <= ((not SWC) and (not SWB) and (not SWA)) and (((not STO) and W1) or (STO and W2 and EI and (not ISINT)));

&#160; &#160; &#160; &#160;INTDI <= ((not SWC) and (not SWB) and (not SWA)) and ((STO and W1 and ISINT) or (STO and DI and (not ISINT)));

&#160; &#160; &#160; &#160;CISINT <= ((not SWC) and (not SWB) and (not SWA)) and STO and ISINT and W2 and T3;

&#160; &#160; &#160; &#160;SISINT <= ((not SWC) and (not SWB) and (not SWA)) and (各条指令执行周期的最后一个节拍 如 ADD and W2) and T3 and WILLPULSE;

### 2.8 计组中断实验理论实现

#### 1.假设

&#160; &#160; &#160; &#160;假设本次实验所使用EPM7128SLC84-15芯片可以从时序发生器接收PULSE信号，并且能够向时序发生器发出LIAR（将PC保存在IAR中）, INTEN（允许中断）, INTDI（屏蔽中断），IABUS（恢复断点地址）四个信号。

#### 2.新增指令

1.DI：指令地址（IR7~IR4）1100. 关中断指令，即屏蔽中断。执行DI后，CPU向时序产生器发送INTDI信号，当时序产生器收到该信号时， 将中断允许触发器EN_INT置为0， 屏蔽中断；

2.EI：指令地址（IR7~IR4）1101. 开中断指令，即允许中断。执行EI后， CPU向时序产生器发送INTEN信号， 当时序产生器收到该信号时， 将中断允许触发器EN_INT置为1， 允许中断。

3.IRET：指令地址（IR7~IR4）1011. 中断服务程序返回指令。执行IRET后，CPU产生IABUS信号，将断点地址送数据总线DBUS，产生信号LPC， 将断点地址从数据总线送入PC，恢复中断的程序。

#### 3.新增辅助信号

1.SSINT：用于设置中断判断的节拍标志位，作用类似于实验内容中的SST0信号。（详情见调试日志），在CLR信号到来时清0；

2.SINT：用于设置中断判断的下降沿标志位，作用类似于实验内容中的ST0信号（详情见调试日志），在CLR信号到来时清0；

3.INPULSE：标志位，为1时表示正在执行中断服务程序，为0时表示处于正常执行指令状态。

#### 4.中断过程描述

&#160; &#160; &#160; &#160;程序正常执行过程中（INPULSE=0），当CPU接收到PULSE信号时，在当前指令的最后一个节拍（视指令为W2或W3）将SSINT设置为1。当T3下降沿到来时，若SSINT为1，则将SINT信号置为1，同时将INPULSE信号置为1，表示开始进入中断处理。CPU进入设置中断向量状态。

&#160; &#160; &#160; &#160;在中断状态的W1拍，CPU首先发出INTDI信号，屏蔽中断，以避免二级中断的发生。然后发出LIAR信号，将PC（当前地址／中断现场）存入断点寄存器IAR。最后发出STOP信号等待输入中断向量即中断服务程序。

&#160; &#160; &#160; &#160;在W2拍，通过打开SBUS输入中断程序地址，发出LPC信号将中断向量存入PC，并在T3下降沿将SSINT和SINT恢复为0，进入正常程序执行状态（但INPULSE仍为1），开始执行中断程序。

&#160; &#160; &#160; &#160;中断程序的倒数第二条指令为EI指令，发出INTEN信号，重新允许中断。同时将INPULSE信号归零。

&#160; &#160; &#160; &#160;中断程序的最后一条指令为IRET指令，从中断地址返回，恢复现场。指令产生IABUS信号，将IAR断点寄存器中的地址重新存入PC，恢复被中断的程序。

&#160; &#160; &#160; &#160;（另外补充：理论上实验系统还应提供另外的寄存器来保存中断前程序的寄存器数据、C／Z标志位等信息，并一同在IRET指令中恢复）

#### 5.VHDL代码描述

#### 6.指令流程图（新增）

## 四.Bug日志

### 4.1写寄存器时顺序出错

当前代码：

```VHDL
CASE SW IS
--顺序：SWC, SWB, SWA
...
WHEN "100" =>
	--写寄存器
	SBUS <= '1';
	SELCTL <= '1';
	DRW <= '1';
	STOP <= '1';
	IF(ST0 = 0) THEN
		SEL(3) <= '0';
		SEL(2) <= NOT W(1);
		SEL(1) <= W(1);
		SEL(0) <= W(1);
		IF(W(2) = '1') THEN
			ST0 := 1;
		END IF;
	ELSE
		SEL(3) <= '1';
		SEL(2) <= NOT W(1);
		SEL(1) <= MOT W(1);
		SEL(0) <= W(1);
	END IF;
...
```

目前情况：

![](/Users/Seagullbird/Desktop/屏幕快照 2016-08-31 15.30.44.png)

按从上到下从左到右顺序标号框1，2，3，4

目前执行顺序为2，1，4，3。（紧跟之后就只有4、3、4、3、4、3…），但寄存器全部正确写入。 （2为无效状态，能正常写入是因为在没到节拍时已经打开了状态门）。

期待结果是按顺序1，2，3，4进行写入四个寄存器操作。

#### 4.1.1更新1

将判断`st0`之前的准备代码替换成：

```VHDL
SBUS <= W(1) OR W(2);
SELCTL <= W(1) OR W(2);
DRW <= W(1) OR W(2);
STOP <= W(1) OR W(2);
```

以确保这些状态门只有在进入节拍后才打开。W(1)和W(2)没亮的时候的状态为无效状态。

#### 4.1.2测试1

在判断`st0`之前加入打印`st0`的代码：


```VHDL
IF (ST0 = 0) THEN
	...
ELSE
	...
END IF;
```

其中省略号借用了其他的灯来显示`st0`。发现在第一拍之后`st0`就变成了1，之后一直是1.（期待的是在第二拍才变成1）。

#### 4.1.3测试2

将`st0`改成`SIGNAL`, `STD_LOGIC`类型，结果一样。

#### 4.1.4解决

W(2)节拍分三段，（T1，T2，T3），将`st0`改为1的动作应该在T3阶段执行。判断时加入条件`AND T3 = '1'`,问题解决。

```VHDL
...
IF(W(2) = '1' AND T3 = '1') THEN
	ST0 <= '1';
END IF;
...
```

最终代码：

```VHDL
CASE SW IS
--顺序：SWC, SWB, SWA
...
WHEN "100" =>
	--写寄存器
	SBUS <= W(1) OR W(2);
	SELCTL <= W(1) OR W(2);
	DRW <= W(1) OR W(2);
	STOP <= W(1) OR W(2);
	
	IF(ST0 = '0') THEN
		SEL(3) <= '0';
		SEL(2) <= NOT W(1);
		SEL(1) <= W(1);
		SEL(0) <= W(1);
		IF(W(2) = '1' AND T3 = '1') THEN
			ST0 <= '1';
		END IF;
	ELSE
		SEL(3) <= '1';
		SEL(2) <= NOT W(1);
		SEL(1) <= MOT W(1);
		SEL(0) <= W(1);
	END IF;
...
```



### 4.2读／写存储器时`st0`一直停留在1

问题其实和上一个问题本质一样，都是`st0`标志位没有按期待所改变。

现在代码如下：

```VHDL
WHEN "001" =>
--xiecun
IF(ST0 = '0') THEN
	SBUS <= W(1);
	LAR <= W(1);
	STOP <= W(1);
	SHORT <= W(1);
	SELCTL <= W(1);
	IF(T3 = '1') THEN
		ST0 <= '1';
	END IF;
ELSE
	SBUS <= W(1);
	MEMW <= W(1);
	ARINC <= W(1);
	STOP <= W(1);
	SHORT <= W(1);
	SELCTL <= W(1);
END IF;

WHEN "010" =>
--ducun
IF(ST0 = '0') THEN
	SBUS <= W(1);
	LAR <= W(1);
	STOP <= W(1);
	SHORT <= W(1);
	SELCTL <= W(1);
	IF(T3 = '1') THEN
		ST0 <= '1';
	END IF;
ELSE
	MBUS <= W(1);
	ARINC <= W(1);
	STOP <= W(1);
	SHORT <= W(1);
	SELCTL <= W(1);
END IF;
```

#### 4.2.1解决

`CLR`之后第一次按`QD`也有一个T3，此时的T3就将`st0`改成了1。应该再加判断`W(1) = '1'`:

```VHDL
...
IF(W(1) = '1' AND T3 = '1') THEN
	ST0 <= '1';
END IF;
```



### 4.3couldn't implement registers for assignments on this clock edge

当前代码：

```VHDL
PROCESS(T3, CLR, W, SW)
	SIGNAL SSTO, STO : STD_LOGIC;
BEGIN
	IF(CLR = '0') THEN
		--清零
		...
	ELSE
		IF(SSTO = '1') THEN
			IF(T3'EVENT AND T3 = '0') THEN --报错
				ST0 = '1';
			END IF;
		END IF;
		CASE SW IS
			...
		END CASE;
	END IF;
END PROCESS;
```

报错出现在注释这一行，提示不能在这里判断时钟。之所以现在改成这个样子是因为不能在`CASE`语句里面判断`T3`下降沿；而不判断下降沿只用`T3 = '1'`来判断的话又会出各种错误。

网上的解释是一个`PROCESS`里面不能有两个时钟上升沿判断，但代码里面并没有。别人的代码目前看来结构和我的一样但是没有这个问题。

#### 4.3.1解决

迷之解决问题，删掉`CASE`语句中`WHEN OTHERS =>`之后的所有内容，编译通过。



### 4.4总结

之前的问题主要集中在标志位`st0`上，按照上面的方法处理了之后，就再也没有问题了。`SST0`的引入保证了`st0`在正确的节拍中开启，外部的`T3`下降沿判断又保证了`st0`只有在`T3`下降沿才会改变。这样处理之后，在下面代码中就可以将`st0`作为一个普通信号，写入到处理其他信号（包括`SST0`）的布尔表达式中去了。（而不必再重复作`if`判断 ）

最终处理方法：

```
PROCESS(T3, CLR, W, SW)
	SIGNAL SSTO, STO : STD_LOGIC;
BEGIN
	IF(CLR = '0') THEN
		--清零
		...
	ELSE
		IF(SSTO = '1') THEN
			IF(T3'EVENT AND T3 = '0') THEN
				ST0 <= '1';
			END IF;
		END IF;
		CASE SW IS
			...
		WHEN OTHERS =>
			--WRITE NOTHING
		END CASE;
	END IF;
END PROCESS;
```

处理过程实例：

```VHDL
...
WHEN "100" =>
	--写寄存器
	SBUS <= W(1) OR W(2);
	SELCTL <= W(1) OR W(2);
	DRW <= W(1) OR W(2);
	STOP <= W(1) OR W(2);
	SST0 <= NOT ST0 AND W(2);
	SEL(3) <= ST0;
	SEL(2) <= W(2);
	SEL(1) <= (NOT ST0 AND W(1)) OR (ST0 AND W(2));
	SEL(0) <= W(1);
...
```

## 五.心得体会

### 1. 加深了对于计算机组成原理的理解

&#160; &#160; &#160; &#160;在计算机组成原理理论课学习中，我们系统性地学习了计算机运算器、存储器、指令系统、CPU、IO设备等内容，这些内容为我们打好了良好的计算机组成原理理论基础，加深了我们对于计算机运行机制的理解。在TEC-8实验平台上，我们实现了计算机指令从存指、取指、执行指令、寄存器存数、寄存器取数的全过程，这些步骤与常规计算机内部的指令机制基本吻合，拟合了计算机指令系统的操作过程，促进了我们对于计算机组成部件的理解。在之前的计算机课程学习中，我们只是停留在单纯的计算机软件运用层面上，我们只是单纯地学习了如何使用计算机程序，如何使用C、C++等编程语言设计并编写可执行软件，但是对于可执行程序在计算机底层的执行过程并不理解，局限了我们在深层次解决计算机相关问题的能力。本次计算机组成原理实验，要求设计采用硬布线控制器的顺序模型处理器，要求我们需要根据硬布线控制器逻辑模块图和硬布线控制器指令周期流程图对VHDL程序进行模块化设计，要求我们了解并掌握TEC-8实验平台上指令执行过程，增强了我们对于计算机底层运行机制的理解。本次实验，可以帮助我们建立计算机的整机意识，帮助我们在以后的计算学习中，能够更深层次地剖析、理解计算机程序运行中遇到的问题，帮助我们能够更好更高效、更迅捷地解决实际遇到的问题。

### 2.培养了团队协作开发的能力

&#160; &#160; &#160; &#160;在计算机可执行程序开发过程中，团队协作、协同开发是必不可少的能力，对于一个大型的计算机可执行程序，单靠一个人的能力是很难高效地完成的。因此，在实际的开发中，就需要小组成员具有团队协作、协同开发的能力，这样的能力能够帮助团队更加高效地完成程序开发、硬件设计、BUG调试的任务，这种能力需要在实际的项目开发中不断地学习改进。本次计算机组成原理课程设计，是软件和硬件相结合的实际项目，对团队的配合能力拥有着较高的要求。一方面，团队需要结合实际功能，根据硬布线控制器指令周期流程图设计出可执行的VHDL代码，配置出VHDL参数对应的引脚，将编译后的硬布线控制器下载到TEC-8实验台上的ISP器件EPM7128中去；另一方面，团队需要对写寄存器、读寄存器、写存储器、读存储器、执行指令进行分模块化调试，最终验证各个模块执行的正确性；最后，我们需要向存储器中写入可执行的指令集，在sw='000'的情况下，执行指令集，单步计算存储器和寄存器中值的变化，验证指令集执行的正确性。对于如上的三项工作，小组成分模块划分，提高了整个项目开展的进度，高效完成了本次实验课程。本次实验，使得我们积累了丰富的计算机项目开发的经验，对我们以后的团队开发大有裨益。

### 3.积累了科学研究的能力和经验

#### 1.模块化开发的能力

&#160; &#160; &#160; &#160;基于硬布线控制器的常规CPU的运行过程依据其参考周期流程图，因此，我们可以采用分模块开发的方式，来逐一实现和测试要实现的功能。本实验中的VHDL程序，主要实现五个主功能，写寄存器、读寄存器、写存储器、读存储器，执行指令。在执行指令功能下，主要实现ADD（加法）、SUB（减法）、AND（逻辑与）、INC（加1）、LD（取数）、ST（存数）、JC（C条件转移）、JZ（Z条件转移）、JMP（无条件转移）、STP（停机）十项操作。本小组首先通过模块划分的方式，逐一实现和验证了写寄、读寄、写存、读存的功能，最后整合代码，在此代码的基础上逐一添加执行指令，最终实现所有的功能。之后通过添加可执行指令集，执行指令集，最终验证CPU设计的正确性。通过模块化划分的方法，可以设计出更加条理清晰的程序，能更加方便我们最终程序的调试，减少不必要的步骤。

#### 2.设计与调试的实践经验

&#160; &#160; &#160; &#160;由于本实验需设计一个硬布线控制器，和TEC-8模型计算机的数据通路结合在一起，构成一个完整的CPU。所以硬布线控制器逻辑的调试需要软件和硬件结合，这与常规情况下的软件开发有区别，需要我们在开发VHDL代码的同时在TEC-8实验平台上进行调试，并且不断地检查并改正其中出现的问题，最终完成代码的设计。在本次计算机组成原理实验过程中，我们观察指示灯在指令执行过程中的亮灭情况，可以判断出程序执行的正误，以此可以单步检查程序中对应的部分，增强了代码调试的效率。

### 参考文献与网页：

>[1]白中英 戴志涛.计算机组成原理[M]北京：科学出版社，2013.12

>[2]戴志涛.采用硬布线控制器的顺序模型处理器设计与调试（PPT）[M]北京：北京邮电大学，2016.7

>[3]系统结构实验室.TEC-8课程设计（PPT）[M]北京，北京邮电大学计算机学院，2016.9

>[4][硬布线控制器的基本思想](http://wenku.baidu.com/link?url=MZrzWJJZzNNsS21BHJbe4w3Lf2u7_tDMftWfKMdXTuQKGwVyPoftP0ZNXRITh6G0sPJoQlGPRd3vUEy2aTc0Z0R3m7xnoG96vKr__5zEGRi)（网址链接）：2010.10
